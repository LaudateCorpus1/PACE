/*
 * Copyright 2016 MIT Lincoln Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.mit.ll.pace.encryption;

import java.util.Map;
import java.util.TreeMap;

import com.google.common.collect.ImmutableList;

/**
 * Defines the set of supported instantiations for {@link ValueEncryptorBase}.
 */
public enum ValueEncryptor {
  AES_SIV_DETERMINISTIC("AES_SIV_DETERMINISTIC", true, true, null), AES_CTR("AES_CTR", false, false, "AES/CTR/NoPadding"), AES_CFB("AES_CFB", false, false,
      "AES/CFB/NoPadding"), AES_CBC("AES_CBC", false, false, "AES/CBC/PKCS5Padding"), AES_OFB("AES_OFB", false, false, "AES/OFB/NoPadding"), AES_GCM("AES_GCM",
      false, false, "AES/GCM/NoPadding");

  /**
   * Valid key sizes for generic AES.
   */
  final static ImmutableList<Integer> VALID_KEY_LENGTHS = ImmutableList.of(16, 24, 32);

  /**
   * Valid key sizes for AES algorithms that need both an aes and an IV-generation key.
   */
  final static ImmutableList<Integer> VALID_DOUBLE_KEY_LENGTHS = ImmutableList.of(32, 48, 64);

  /**
   * Set of ValueEncryptor names mapped to the ValueEncryptor enum object. Used to speed up name lookups.
   */
  private static final Map<String,ValueEncryptor> encryptors;
  static {
    encryptors = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    for (ValueEncryptor encryptor : values()) {
      encryptors.put(encryptor.name, encryptor);
    }
  }

  /**
   * Name of the encryptor.
   */
  private final String name;

  /**
   * Whether the encryptor is deterministic in its encryption of ciphertext (i.e., same value produces the same encrypted ciphertext).
   */
  private final boolean deterministic;

  /**
   * Whether the encryptor needs two keys, an encryption and iv-generation key.
   */
  private final boolean needsTwoKeys;

  /**
   * Transformation used by this encryptor, or null if the encryptor's implementation does not rely on {@link javax.crypto.Cipher#getInstance(String, String)}.
   * <p>
   * The transformation defines the algorithm used, the mode it is used in, and any padding.
   */
  private final String transformation;

  /**
   * Create the value encryptor.
   *
   * @param name
   *          Name of the encryptor.
   * @param deterministic
   *          Whether the encryptor is deterministic in its encryption of ciphertext (i.e., same value produces the same encrypted ciphertext).
   * @param needsTwoKeys
   *          Whether the encryptor needs two keys, an encryption and iv-generation key.
   * @param transformation
   *          Transformation used by this encryptor, or null if the encryptor's implementation does not rely on
   *          {@link javax.crypto.Cipher#getInstance(String, String)}.
   */
  ValueEncryptor(String name, boolean deterministic, boolean needsTwoKeys, String transformation) {
    this.name = name;
    this.deterministic = deterministic;
    this.needsTwoKeys = needsTwoKeys;
    this.transformation = transformation;
  }

  @Override
  public String toString() {
    return this.name;
  }

  /**
   * Get the value encryptor from its {@link String} representation.
   * <p>
   * This method is paired with {@link #toString()}, and will parse strings generated by that method.
   *
   * @param value
   *          Value to parse.
   * @return ValueEncryptor for the value.
   */
  static ValueEncryptor fromString(String value) {
    ValueEncryptor encryptor = encryptors.get(value);
    if (encryptor == null) {
      throw new IllegalArgumentException("invalid name");
    }
    return encryptor;
  }

  /**
   * Gets whether this encryptor is deterministic.
   *
   * @return Whether this encryptor is deterministic.
   */
  boolean isDeterministic() {
    return deterministic;
  }

  /**
   * Gets the default key length for this encryptor.
   *
   * @return The default key length of this encryptor.
   */
  int getDefaultKeyLength() {
    return (needsTwoKeys ? VALID_DOUBLE_KEY_LENGTHS : VALID_KEY_LENGTHS).get(0);
  }

  /**
   * Gets whether the key length is valid for this encryptor.
   *
   * @param keyLength
   *          Length of the key to check for validity.
   * @return Whether the given key length is valid for this encryptor.
   */
  boolean isValidKeyLength(int keyLength) {
    return (needsTwoKeys ? VALID_DOUBLE_KEY_LENGTHS : VALID_KEY_LENGTHS).contains(keyLength);
  }

  /**
   * Gets a new {@link ValueEncryptorBase} instance for the encryptor.
   *
   * @param provider
   *          Provider to use when creating the instance.
   * @return The created instance.
   */
  ValueEncryptorBase getInstance(String provider) {
    switch (this) {
      case AES_SIV_DETERMINISTIC:
        return new DeterministicSIVValueEncryptor();

      case AES_CTR:
      case AES_CFB:
      case AES_CBC:
      case AES_OFB:
      case AES_GCM:
        return new AESValueEncryptor(transformation, provider);

      default:
        throw new UnsupportedOperationException();
    }
  }

}
