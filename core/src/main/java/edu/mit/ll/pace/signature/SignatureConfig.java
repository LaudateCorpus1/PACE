/*
 * Copyright 2016 MIT Lincoln Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.mit.ll.pace.signature;

import static com.google.common.base.Preconditions.checkArgument;
import static edu.mit.ll.pace.internal.Utils.VISIBILITY_CHARSET;

import java.io.IOException;
import java.io.Writer;
import java.util.Map;
import java.util.TreeMap;

import org.ini4j.Ini;
import org.ini4j.Profile.Section;

import com.google.common.base.Strings;

/**
 * Configuration for signing entries.
 */
public final class SignatureConfig {

  /**
   * INI section to write data to.
   */
  static final String SECTION_NAME = "Signature";

  /**
   * Where the signature should be written.
   */
  public enum Destination {
    VALUE("value"), COLUMN_VISIBILITY("colVis"), SEPARATE_TABLE("table");

    /**
     * Set of EntryField names mapped to the EntryField enum object. Used to speed up name lookups.
     */
    private static final Map<String,Destination> destinations;
    static {
      destinations = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
      for (Destination destination : values()) {
        destinations.put(destination.name, destination);
      }
    }

    /**
     * A string representation of the Destination.
     */
    private final String name;

    /**
     * Create an Destination with the given name.
     *
     * @param name
     *          Name of the entry field. Used in the configuration INI.
     */
    Destination(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return this.name;
    }

    /**
     * Get the destination from its {@link String} representation.
     * <p>
     * This method is paired with {@link #toString()}, and will parse strings generated by that method.
     *
     * @param value
     *          Value to parse.
     * @return Destination for the value.
     */
    static Destination fromString(String value) {
      Destination destination = destinations.get(value);
      if (destination == null) {
        throw new IllegalArgumentException("invalid name");
      }
      return destination;
    }

  }

  /**
   * The algorithm to use to sign entries.
   */
  final ValueSigner algorithm;

  /**
   * The provider to use for creating the {@link java.security.Signature}.
   */
  final String provider;

  /**
   * The destination where the signature is written to or read from.
   */
  final Destination destination;

  /**
   * The table that will store the signatures.
   */
  final String destinationTable;

  /**
   * Default visibility to use when wrapping data in the column visibility field.
   */
  final byte[] defaultVisibility;

  /**
   * Create a configuration for signing entries.
   *
   * @param signer
   *          The algorithm to use to sign entries.
   * @param provider
   *          The provider to use for creating the {@link java.security.Signature}.
   * @param destination
   *          The destination where the signature is written to or read from.
   * @param destinationTable
   *          The table that will store the signatures.
   * @param defaultVisibility
   *          Default visibility to use when wrapping signature in a visibility field.
   */
  SignatureConfig(ValueSigner signer, String provider, Destination destination, String destinationTable, byte[] defaultVisibility) {
    checkArgument(signer != null, "signer is null");
    checkArgument(destination != null, "destination is null");

    if (destination == Destination.SEPARATE_TABLE) {
      checkArgument(!Strings.isNullOrEmpty(destinationTable), "destination table is null or empty");
    } else {
      checkArgument(destinationTable == null, "destination table is not null, but not needed");
    }

    if (destination == Destination.COLUMN_VISIBILITY) {
      checkArgument(defaultVisibility != null && defaultVisibility.length != 0, "defaultVisibility is null or empty, but needed");
    } else {
      checkArgument(defaultVisibility == null, "default is not null, but should be");
    }

    this.algorithm = signer;
    this.provider = provider;
    this.destination = destination;
    this.destinationTable = destinationTable;
    this.defaultVisibility = defaultVisibility;
  }

  /**
   * Write the object to a Writer.
   *
   * @param out
   *          Stream to write object out to.
   */
  public void write(Writer out) throws IOException {
    Ini configIni = new Ini();
    Section section = configIni.add(SECTION_NAME);

    section.put("algorithm", algorithm.toString());
    section.put("provider", provider);
    section.put("destination", destination.toString());
    if (destinationTable != null) {
      section.put("table", destinationTable);
    }
    if (defaultVisibility != null) {
      section.put("defaultVisibility", new String(defaultVisibility, VISIBILITY_CHARSET));
    }

    configIni.store(out);
  }

  /**
   * Gets whether this config write to a separate signature table.
   */
  public boolean isSignatureInSeparateTable() {
    return this.destination == Destination.SEPARATE_TABLE;
  }

  /**
   * Gets the algorithm for this signer.
   * <p>
   * The key supplied to the {@link EntrySigner} must match this algorithm.
   *
   * @return Algorithm Algorithm defined by this config.
   */
  public ValueSigner getAlgorithm() {
    return this.algorithm;
  }

}
