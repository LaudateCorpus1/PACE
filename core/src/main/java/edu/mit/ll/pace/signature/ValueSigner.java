/*
 * Copyright 2016 MIT Lincoln Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.mit.ll.pace.signature;

import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Signature;
import java.util.Map;
import java.util.TreeMap;

/**
 * Set of objects that can sign values.
 */
public enum ValueSigner {
  RSA_PKCS1("RSA-PKCS1", "SHA256withRSA", "RSA"), RSA_PSS("RSA-PSS", "SHA256withRSA/PSS", "RSA"), DSA("DSA", "SHA256withDSA", "DSA"), ECDSA("ECDSA",
      "SHA256withECDSA", "ECDSA");

  /**
   * Set of ValueSigner names mapped to the ValueSigner enum object. Used to speed up name lookups.
   */
  private static final Map<String,ValueSigner> signers;
  static {
    signers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    for (ValueSigner signer : values()) {
      signers.put(signer.name, signer);
    }
  }

  /**
   * Name of the signer.
   */
  private final String name;

  /**
   * Algorithm used for the singer.
   */
  private final String algorithm;

  /**
   * Algorithm that can be used to generate keys for use with this cipher.
   */
  private final String keyGenerationAlgorithm;

  /**
   * Create the value signer.
   *
   * @param name
   *          Name of the algorithm.
   * @param algorithm
   *          Algorithm used by this signer.
   * @param keyGenerationAlgorithm
   *          Algorithm that can be used to generate keys for use with this cipher.
   */
  ValueSigner(String name, String algorithm, String keyGenerationAlgorithm) {
    this.name = name;
    this.algorithm = algorithm;
    this.keyGenerationAlgorithm = keyGenerationAlgorithm;
  }

  @Override
  public String toString() {
    return this.name;
  }

  /**
   * Get the value signer from its {@link String} representation.
   * <p>
   * This method is paired with {@link #toString()}, and will parse strings generated by that method.
   *
   * @param value
   *          Value to parse.
   * @return ValueSigner for the value.
   */
  static ValueSigner fromString(String value) {
    ValueSigner signer = signers.get(value);
    if (signer == null) {
      throw new IllegalArgumentException("invalid name");
    }
    return signer;
  }

  /**
   * Get the algorithm that can be used to generate keys for use with this cipher.
   *
   * @return Key generation algorithm.
   */
  public String getKeyGenerationAlgorithm() {
    return keyGenerationAlgorithm;
  }

  /**
   * Gets a new {@link Signature} instance for the signer.
   *
   * @param provider
   *          Provider to use when creating the instance, or null to allow the system to decide which provider to use.
   * @return The created instance.
   */
  Signature getInstance(String provider) {
    try {
      if (provider == null) {
        return Signature.getInstance(algorithm);
      } else {
        return Signature.getInstance(algorithm, provider);
      }
    } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
      throw new SignatureException(e);
    }
  }

}
